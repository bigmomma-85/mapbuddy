<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>MapBuddy - Asset to Map File Converter</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: { extend: { colors: { 'map-blue':'#2563eb','map-green':'#059669','map-orange':'#ea580c' } } }
    }
 <script>
/* ========= Deploy tweak =========
   If your app is hosted under a sub-path (e.g., /mapbuddy), set API_BASE = '/mapbuddy'.
   Otherwise leave it as ''.
*/
const API_BASE = '';

/* ========= Endpoints to try (in order) ========= */
const SINGLE_ENDPOINTS = [
  `${API_BASE}/api/single`,          // preferred
  `${API_BASE}/api/download`,        // fallback some older builds
  `${API_BASE}/api/convert`,         // generic fallback
  `${API_BASE}/api/asset`            // last-resort
];

const BULK_ENDPOINTS = [
  `${API_BASE}/api/bulk`,            // preferred
  `${API_BASE}/api/convert/bulk`,    // fallback
  `${API_BASE}/api/download/bulk`    // last-resort
];

const LINK_ENDPOINTS = [
  `${API_BASE}/api/link`,
  `${API_BASE}/api/maps`,
  `${API_BASE}/api/google`
];

/* ========= Format mappings =========
   Single tries a small ladder per format.
   Bulk must be zipped: kmlzip / geojsonzip / shpzip.
*/
const SINGLE_FORMAT_LADDER = {
  kml:      ['kml', 'kmlzip'],
  geojson:  ['geojson', 'geojsonzip'],
  shapefile:['shp', 'shpzip', 'shapefilezip']
};

const BULK_FORMAT_MAP = {
  kml:      ['kmlzip', 'kml'],        // will try zipped first
  geojson:  ['geojsonzip', 'geojson'],
  shapefile:['shpzip', 'shapefilezip']
};

/* ========= Small helpers ========= */
function suggestedFilenameFromResponse(res, fallback) {
  const cd = res.headers.get('content-disposition');
  if (cd) {
    const m = cd.match(/filename\*=UTF-8''([^;]+)|filename="?([^"]+)"?/i);
    if (m) return decodeURIComponent(m[1] || m[2]);
  }
  return fallback;
}

function saveBlob(blob, name = 'download.bin') {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function tryPOSTBinary(url, payload) {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  if (!res.ok) throw new Error(`POST ${url} → ${res.status}`);
  const blob = await res.blob();
  return { res, blob };
}

async function tryGETJSON(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`GET ${url} → ${res.status}`);
  return res.json();
}

/* ========= UI elements ========= */
const singleModeBtn = document.getElementById('singleModeBtn');
const bulkModeBtn   = document.getElementById('bulkModeBtn');
const singleMode    = document.getElementById('singleMode');
const bulkMode      = document.getElementById('bulkMode');

const datasetSelect     = document.getElementById('datasetSelect');
const assetNumber       = document.getElementById('assetNumber');
const singleConvertBtn  = document.getElementById('singleConvertBtn');
const formatCheckboxes  = document.querySelectorAll('input[name="format"]');

const bulkDatasetSelect   = document.getElementById('bulkDatasetSelect');
const csvUploadArea       = document.getElementById('csvUploadArea');
const bulkConvertBtn      = document.getElementById('bulkConvertBtn');
const bulkFormatCheckboxes= document.querySelectorAll('input[name="bulkFormat"]');

const googleMapsSection = document.getElementById('googleMapsSection');

let csvUploaded = false;
let currentGoogleLink = null;

/* ========= Mode switching ========= */
singleModeBtn.addEventListener('click', () => {
  singleModeBtn.classList.add('bg-gradient-to-r','from-map-blue','to-map-green','text-white');
  bulkModeBtn.classList.remove('bg-gradient-to-r','from-map-blue','to-map-green','text-white');
  bulkModeBtn.classList.add('text-gray-600');
  singleMode.classList.remove('hidden');
  bulkMode.classList.add('hidden');
});

bulkModeBtn.addEventListener('click', () => {
  bulkModeBtn.classList.add('bg-gradient-to-r','from-map-blue','to-map-green','text-white');
  singleModeBtn.classList.remove('bg-gradient-to-r','from-map-blue','to-map-green','text-white');
  singleModeBtn.classList.add('text-gray-600');
  bulkMode.classList.remove('hidden');
  singleMode.classList.add('hidden');
});

/* ========= Enable / Disable Single button ========= */
function checkSingleConvertReady() {
  const hasDataset = datasetSelect && datasetSelect.value;
  const hasAsset   = assetNumber && assetNumber.value.trim();
  const hasFormat  = Array.from(formatCheckboxes).some(cb => cb.checked);
  singleConvertBtn.disabled = !(hasDataset && hasAsset && hasFormat);
}

datasetSelect?.addEventListener('change', checkSingleConvertReady);
assetNumber?.addEventListener('input', checkSingleConvertReady);
formatCheckboxes.forEach(cb => cb.addEventListener('change', checkSingleConvertReady));

/* ========= Enable / Disable Bulk button ========= */
function checkBulkConvertReady() {
  const hasDataset = bulkDatasetSelect && bulkDatasetSelect.value;
  const hasFormat  = Array.from(bulkFormatCheckboxes).some(cb => cb.checked);
  bulkConvertBtn.disabled = !(csvUploaded && hasDataset && hasFormat);
}

bulkDatasetSelect?.addEventListener('change', checkBulkConvertReady);
bulkFormatCheckboxes.forEach(cb => cb.addEventListener('change', checkBulkConvertReady));

/* ========= CSV Upload (mock click to “load”) ========= */
csvUploadArea?.addEventListener('click', () => {
  csvUploadArea.classList.add('border-map-blue','bg-blue-50');
  setTimeout(() => {
    csvUploaded = true; // mark as uploaded
    checkBulkConvertReady();
  }, 300);
});

/* ========= SINGLE: download & link ========= */
singleConvertBtn?.addEventListener('click', async () => {
  if (singleConvertBtn.disabled) return;

  const datasetKey = datasetSelect.value;            // your page already uses actual API keys here
  const assetId    = assetNumber.value.trim();
  const formats    = Array.from(formatCheckboxes).filter(cb => cb.checked).map(cb => cb.value); // kml, geojson, shapefile

  singleConvertBtn.innerHTML = 'Generating Files...';
  singleConvertBtn.disabled = true;

  try {
    // For each selected format, try its ladder until one works
    for (const uiFmt of formats) {
      const ladder = SINGLE_FORMAT_LADDER[uiFmt] || [uiFmt];
      let success = false, lastErr;

      for (const fmt of ladder) {
        for (const ep of SINGLE_ENDPOINTS) {
          try {
            const payload = { assetId, dataset: datasetKey, format: fmt };
            const { res, blob } = await tryPOSTBinary(ep, payload);
            const fallbackName = `${assetId}_${fmt}.bin`;
            const fname = suggestedFilenameFromResponse(res, fallbackName);
            saveBlob(blob, fname);
            success = true;
            break; // endpoint ok
          } catch (e) {
            lastErr = e;
            continue; // try next endpoint
          }
        }
        if (success) break; // format ok
      }

      if (!success && lastErr) throw lastErr;
    }

    // After success, fetch Google Maps link
    currentGoogleLink = await getGoogleLink(assetId, datasetKey);
    if (currentGoogleLink) {
      googleMapsSection.classList.remove('hidden');
    }
    singleConvertBtn.innerHTML = 'Download Files';
    singleConvertBtn.disabled = false;
    singleConvertBtn.classList.remove('from-map-blue','to-map-green');
    singleConvertBtn.classList.add('from-green-500','to-green-600');
  } catch (err) {
    console.error(err);
    alert('Single conversion failed. Please retry.');
    singleConvertBtn.innerHTML = 'Generate Map Files';
    singleConvertBtn.disabled = false;
    singleConvertBtn.classList.remove('from-green-500','to-green-600');
    singleConvertBtn.classList.add('from-map-blue','to-map-green');
  }
});

/* ========= BULK: download zip(s) ========= */
bulkConvertBtn?.addEventListener('click', async () => {
  if (bulkConvertBtn.disabled) return;

  const datasetKey = bulkDatasetSelect.value;
  const selected   = Array.from(bulkFormatCheckboxes).filter(cb => cb.checked).map(cb => cb.value); // kml, geojson, shapefile

  bulkConvertBtn.innerHTML = 'Processing Assets...';
  bulkConvertBtn.disabled  = true;

  try {
    for (const uiFmt of selected) {
      const candidates = BULK_FORMAT_MAP[uiFmt] || [uiFmt];
      let success = false, lastErr;

      for (const fmt of candidates) {
        for (const ep of BULK_ENDPOINTS) {
          try {
            /* Expecting your API body like:
               { items:[{assetId:"..."}, ...], defaultDataset:"...", format:"kmlzip|geojsonzip|shpzip" }
               Here we send only the format/dataset because your API builds items from the uploaded CSV server-side.
               If your API *requires* items here, wire your parsed rows and send them in `items`.
            */
            const payload = { defaultDataset: datasetKey, format: fmt };
            const { res, blob } = await tryPOSTBinary(ep, payload);
            const fallbackName = `mapbuddy_${fmt}.zip`;
            const fname = suggestedFilenameFromResponse(res, fallbackName);
            saveBlob(blob, fname);
            success = true;
            break;
          } catch (e) {
            lastErr = e;
            continue;
          }
        }
        if (success) break;
      }

      if (!success && lastErr) throw lastErr;
    }

    bulkConvertBtn.innerHTML = 'Download Bulk Files';
    bulkConvertBtn.disabled  = false;
    bulkConvertBtn.classList.remove('from-map-blue','to-map-green');
    bulkConvertBtn.classList.add('from-green-500','to-green-600');
  } catch (err) {
    console.error(err);
    alert('Bulk conversion failed. Please retry.');
    bulkConvertBtn.innerHTML = 'Process Bulk Conversion';
    bulkConvertBtn.disabled  = false;
    bulkConvertBtn.classList.remove('from-green-500','to-green-600');
    bulkConvertBtn.classList.add('from-map-blue','to-map-green');
  }
});

/* ========= Google Maps helpers ========= */
async function getGoogleLink(assetId, datasetKey) {
  // Try an API link builder first
  for (const ep of LINK_ENDPOINTS) {
    try {
      const url = `${ep}?assetId=${encodeURIComponent(assetId)}&dataset=${encodeURIComponent(datasetKey)}`;
      const json = await tryGETJSON(url);
      if (json && json.url) return json.url;
    } catch (e) {
      continue;
    }
  }
  // Fallback: very simple Maps query (not feature-precise, but better than nothing)
  return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(assetId + ' ' + datasetKey)}`;
}

window.copyGoogleMapsLink = function() {
  if (!currentGoogleLink) return;
  navigator.clipboard.writeText(currentGoogleLink).then(() => {
    alert('Google Maps link copied!');
  });
};

window.openGoogleMaps = function() {
  if (!currentGoogleLink) return;
  window.open(currentGoogleLink, '_blank', 'noopener,noreferrer');
};
</script>

    /* ================= CONFIG ================= */
    const API_BASE = ''; // e.g. '' or '/mapbuddy'

    // dataset codes your API expects
    const DATASETS = {
      fairfax_bmps: 'fairfax_bmps',
      mdsha_landscape: 'mdsha_landscape',
      tmdl_scs: 'tmdl_scs',
      tmdl_retrofits: 'tmdl_retrofits',
      tmdl_tree_plantings: 'tmdl_tree_plantings',
      tmdl_pavement_removals: 'tmdl_pavement_removals',
      tmdl_stream_restorations: 'tmdl_stream_restorations',
      tmdl_outfall_stabilizations: 'tmdl_outfall_stabilizations'
    };

    // format tokens for your backend
    const SINGLE_FORMAT = { kml:'kml', geojson:'geojson', shapefile:'shpzip' };
    const BULK_FORMAT   = { kml:'kmlzip', geojson:'geojson', shapefile:'shpzip' };

    const SINGLE_URL = (q) => `${API_BASE}/api/single?assetId=${encodeURIComponent(q.assetId)}&dataset=${encodeURIComponent(q.dataset)}&format=${encodeURIComponent(q.format)}`;
    const BULK_ENDPOINTS = [
      ({format,defaultDataset}) => `${API_BASE}/api/bulk`,
      ({format,defaultDataset}) => `${API_BASE}/api/bulk?format=${encodeURIComponent(format)}&defaultDataset=${encodeURIComponent(defaultDataset)}`,
      ({format,defaultDataset}) => `${API_BASE}/api/bulk/${encodeURIComponent(format)}?defaultDataset=${encodeURIComponent(defaultDataset)}`
    ];
    const MAP_LINK_ENDPOINTS = [
      ({assetId,dataset}) => `${API_BASE}/api/link?assetId=${encodeURIComponent(assetId)}&dataset=${encodeURIComponent(dataset)}`,
      ({assetId,dataset}) => `${API_BASE}/api/maps-link?assetId=${encodeURIComponent(assetId)}&dataset=${encodeURIComponent(dataset)}`,
      ({assetId,dataset}) => `${API_BASE}/api/link/single?assetId=${encodeURIComponent(assetId)}&dataset=${encodeURIComponent(dataset)}`
    ];

    /* ============== Mode toggle ============== */
    const singleModeBtn=document.getElementById('singleModeBtn');
    const bulkModeBtn=document.getElementById('bulkModeBtn');
    const singleMode=document.getElementById('singleMode');
    const bulkMode=document.getElementById('bulkMode');
    singleModeBtn.addEventListener('click',()=>{singleModeBtn.classList.add('bg-gradient-to-r','from-map-blue','to-map-green','text-white');singleModeBtn.classList.remove('text-gray-600');bulkModeBtn.classList.remove('bg-gradient-to-r','from-map-blue','to-map-green','text-white');bulkModeBtn.classList.add('text-gray-600');singleMode.classList.remove('hidden');bulkMode.classList.add('hidden')});
    bulkModeBtn.addEventListener('click',()=>{bulkModeBtn.classList.add('bg-gradient-to-r','from-map-blue','to-map-green','text-white');bulkModeBtn.classList.remove('text-gray-600');singleModeBtn.classList.remove('bg-gradient-to-r','from-map-blue','to-map-green','text-white');singleModeBtn.classList.add('text-gray-600');bulkMode.classList.remove('hidden');singleMode.classList.add('hidden')});

    /* ============== Single ============== */
    const datasetSelect=document.getElementById('datasetSelect');
    const assetNumber=document.getElementById('assetNumber');
    const singleConvertBtn=document.getElementById('singleConvertBtn');
    const formatCheckboxes=document.querySelectorAll('input[name="format"]');
    const singleError=document.getElementById('singleError');
    const gmapsSection=document.getElementById('googleMapsSection');
    const copyGmapsBtn=document.getElementById('copyGmapsBtn');
    const openGmapsBtn=document.getElementById('openGmapsBtn');
    let gmapsUrl='';

    function canRunSingle(){
      const d=datasetSelect.value.trim();
      const a=assetNumber.value.trim();
      const f=Array.from(formatCheckboxes).some(cb=>cb.checked);
      singleConvertBtn.disabled=!(d&&a&&f);
    }
    datasetSelect.addEventListener('change',canRunSingle);
    assetNumber.addEventListener('input',canRunSingle);
    formatCheckboxes.forEach(cb=>cb.addEventListener('change',canRunSingle));

    singleConvertBtn.addEventListener('click', async ()=>{
      if(singleConvertBtn.disabled) return;
      singleError.classList.add('hidden'); singleError.textContent='';
      gmapsSection.classList.add('hidden'); gmapsUrl='';

      const assetId=assetNumber.value.trim().toUpperCase();
      const dataset=DATASETS[datasetSelect.value]||datasetSelect.value;
      const selected=Array.from(formatCheckboxes).filter(cb=>cb.checked).map(cb=>cb.value);

      singleConvertBtn.textContent='Generating Files...';
      singleConvertBtn.disabled=true;

      try{
        for(const fmt of selected){
          const format=SINGLE_FORMAT[fmt]||fmt;

          // Try GET first (file stream)
          let fetched=false;
          try{
            const url=SINGLE_URL({assetId,dataset,format});
            const a=document.createElement('a'); a.href=url; a.style.display='none'; document.body.appendChild(a); a.click(); a.remove();
            fetched=true;
          }catch{ /* noop */ }

          // Fallback to POST returning blob
          if(!fetched){
            const res=await fetch(`${API_BASE}/api/single`,{
              method:'POST',
              headers:{'Content-Type':'application/json','Accept':'*/*'},
              body:JSON.stringify({assetId,dataset,format})
            });
            if(!res.ok){
              const txt=await safeText(res);
              throw new Error(`Single ${format} failed ${res.status}: ${txt}`);
            }
            const blob=await res.blob();
            const name=getFilename(res.headers) || `${assetId}_${format}.zip`;
            downloadBlob(blob,name);
          }
          await delay(300);
        }

        // Maps link (best-effort)
        for(const build of MAP_LINK_ENDPOINTS){
          try{
            const r=await fetch(build({assetId,dataset}));
            if(r.ok){
              const j=await r.json();
              if(j?.url){ gmapsUrl=j.url; openGmapsBtn.href=gmapsUrl; gmapsSection.classList.remove('hidden'); break; }
            }
          }catch{}
        }

        singleConvertBtn.textContent='Download Again';
      }catch(err){
        singleError.textContent=err.message;
        singleError.classList.remove('hidden');
        singleConvertBtn.textContent='Generate Map Files';
      }finally{
        singleConvertBtn.disabled=false;
      }
    });

    copyGmapsBtn.addEventListener('click', async ()=>{
      if(!gmapsUrl) return;
      try{ await navigator.clipboard.writeText(gmapsUrl); copyGmapsBtn.textContent='Copied!'; setTimeout(()=>copyGmapsBtn.textContent='Copy Link',1200);}catch{}
    });

    /* ============== Bulk ============== */
    const bulkDatasetSelect=document.getElementById('bulkDatasetSelect');
    const csvUploadArea=document.getElementById('csvUploadArea');
    const csvFileInput=document.getElementById('csvFileInput');
    const chooseCsvBtn=document.getElementById('chooseCsvBtn');
    const csvStatus=document.getElementById('csvStatus');
    const bulkConvertBtn=document.getElementById('bulkConvertBtn');
    const bulkError=document.getElementById('bulkError');
    const bulkFormatCbs=document.querySelectorAll('input[name="bulkFormat"]');

    let bulkRows=[];

    chooseCsvBtn.addEventListener('click',()=>csvFileInput.click());
    csvUploadArea.addEventListener('click',e=>{ if(e.target===csvUploadArea) csvFileInput.click(); });

    csvFileInput.addEventListener('change', async (e)=>{
      const file=e.target.files?.[0]; if(!file) return;
      const text=await file.text();
      bulkRows=parseCsv(text);
      csvStatus.textContent=`Loaded ${bulkRows.length} assets`;
      csvUploadArea.classList.add('border-map-blue','bg-blue-50');
      checkBulkReady();
    });

    function parseCsv(text){
      const rows=text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      if(rows.length===0) return [];
      let i=0; if(/asset|id/i.test(rows[0])) i=1;
      const out=[];
      for(;i<rows.length;i++){
        const cols=rows[i].split(/[;,]|,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(c=>c.replace(/^"|"$/g,'').trim());
        if(!cols[0]) continue;
        const assetId=cols[0].toUpperCase();
        const dsRaw=(cols[1]||'').trim();
        const ds = normalizeDataset(dsRaw);
        out.push(ds ? {assetId,dataset:ds} : {assetId});
      }
      return out;
    }
    function normalizeDataset(v){
      if(!v) return null; const s=v.toLowerCase();
      for(const k of Object.keys(DATASETS)){
        if(s===k.toLowerCase() || s===DATASETS[k].toLowerCase()) return DATASETS[k];
      }
      if(s.includes('fairfax')) return DATASETS.fairfax_bmps;
      if(s.includes('landscape')) return DATASETS.mdsha_landscape;
      if(s.includes('control')) return DATASETS.tmdl_scs;
      if(s.includes('retrofit')) return DATASETS.tmdl_retrofits;
      if(s.includes('tree')) return DATASETS.tmdl_tree_plantings;
      if(s.includes('pavement')) return DATASETS.tmdl_pavement_removals;
      if(s.includes('stream')) return DATASETS.tmdl_stream_restorations;
      if(s.includes('outfall')) return DATASETS.tmdl_outfall_stabilizations;
      return null;
    }
    function checkBulkReady(){
      const hasCsv=bulkRows.length>0;
      const hasDs=!!bulkDatasetSelect.value;
      const hasFmt=Array.from(bulkFormatCbs).some(cb=>cb.checked);
      bulkConvertBtn.disabled=!(hasCsv&&hasDs&&hasFmt);
    }
    bulkDatasetSelect.addEventListener('change',checkBulkReady);
    bulkFormatCbs.forEach(cb=>cb.addEventListener('change',checkBulkReady));

    bulkConvertBtn.addEventListener('click', async ()=>{
      if(bulkConvertBtn.disabled) return;
      bulkError.classList.add('hidden'); bulkError.textContent='';

      const defaultDataset=DATASETS[bulkDatasetSelect.value]||bulkDatasetSelect.value;
      const fmts=Array.from(bulkFormatCbs).filter(cb=>cb.checked).map(cb=>cb.value);

      bulkConvertBtn.textContent='Processing Assets...';
      bulkConvertBtn.disabled=true;

      try{
        for(const f of fmts){
          const format=BULK_FORMAT[f]||f;

          // two body variants: with defaultDataset, and with dataset per item
          const bodyA={ items: bulkRows, defaultDataset, format };
          const itemsWithDs=bulkRows.map(r=> r.dataset ? r : ({...r, dataset: defaultDataset}));
          const bodyB={ items: itemsWithDs, format };

          let downloaded=false;
          // try each endpoint with bodyA then bodyB
          for(const build of BULK_ENDPOINTS){
            const url=build({format,defaultDataset});
            // A
            if(!downloaded) downloaded = await tryBulkPost(url, bodyA, guessFilename(format));
            // B
            if(!downloaded) downloaded = await tryBulkPost(url, bodyB, guessFilename(format));
            if(downloaded) break;
          }
          if(!downloaded){
            throw new Error(`Bulk ${format} failed: no endpoint accepted request.`);
          }
          await delay(350);
        }
        bulkConvertBtn.textContent='Download Again';
      }catch(err){
        bulkError.textContent = err.message;
        bulkError.classList.remove('hidden');
        bulkConvertBtn.textContent='Process Bulk Conversion';
      }finally{
        bulkConvertBtn.disabled=false;
      }
    });

    async function tryBulkPost(url, body, fallbackName){
      try{
        const res=await fetch(url,{
          method:'POST',
          headers:{'Content-Type':'application/json','Accept':'application/zip,application/octet-stream,*/*'},
          body:JSON.stringify(body)
        });
        if(!res.ok){
          // read any error text to surface the backend message
          const txt=await safeText(res);
          // treat 404/405 as "try next"
          if(res.status===404 || res.status===405) return false;
          throw new Error(`${res.status} ${res.statusText}${txt?': '+txt:''}`);
        }
        const ctype=(res.headers.get('content-type')||'').toLowerCase();
        if(ctype.includes('application/json')){
          const j=await res.json();
          if(j?.error || j?.message) throw new Error(j.error||j.message);
          // if server returns a signed URL
          if(j?.url){ window.location.href=j.url; return true; }
          // unknown json -> try as text
          throw new Error('Unexpected JSON response from bulk endpoint.');
        }
        const blob=await res.blob();
        const name=getFilename(res.headers) || fallbackName;
        downloadBlob(blob,name);
        return true;
      }catch(e){
        // Only bubble up for non-404/405 thrown above; here treat network as "try next"
        return false;
      }
    }

    /* ============== helpers ============== */
    function guessFilename(format){
      const ts=new Date().toISOString().slice(0,10);
      return `mapbuddy_${format}_${ts}.zip`;
    }
    function getFilename(headers){
      const cd=headers.get('content-disposition'); if(!cd) return null;
      const m=/filename\*=UTF-8''([^;]+)|filename="?([^"]+)"?/i.exec(cd);
      return decodeURIComponent(m?.[1]||m?.[2]||'');
    }
    function downloadBlob(blob,filename){
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    const delay=(ms)=>new Promise(r=>setTimeout(r,ms));
    async function safeText(res){ try{ return await res.text(); }catch{ return ''; } }
  </script>
</body>
</html>
